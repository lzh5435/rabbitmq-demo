package test.liuzehua.rabbitmqdemo.rpc;import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.DeliverCallback;import test.liuzehua.rabbitmqdemo.utils.ConnectionFactoryUtil;public class RPCServer {    private static final String RPC_QUEUE_NAME = "rpc_queue";    private static int fib(int n) {        if (n == 0) return 0;        if (n == 1) return 1;        return fib(n - 1) + fib(n - 2);    }    public static void main(String[] argv) throws Exception {        try (Connection connection = ConnectionFactoryUtil.getConnection();             Channel channel = connection.createChannel()) {            channel.queueDeclare(RPC_QUEUE_NAME, false, false, false, null);            channel.queuePurge(RPC_QUEUE_NAME);            channel.basicQos(1);            System.out.println(" [x] Awaiting RPC requests");            Object monitor = new Object();            DeliverCallback deliverCallback = (consumerTag, delivery) ->    {                AMQP.BasicProperties replyProps = new AMQP.BasicProperties                        .Builder()                        .correlationId(delivery.getProperties().getCorrelationId())                        .build();                String response = "";                try {                    String message = new String(delivery.getBody(), "UTF-8");                    int n = Integer.parseInt(message);                    System.out.println(" [.] fib(" + message + ")");                    response += fib(n);                } catch (RuntimeException e) {                    System.out.println(" [.] " + e.toString());                } finally {                    // 将结果返回给客户端  返回给请求来的队列 delivery.getProperties().getReplyTo()                    // 将请求标识 返回replyProps  .correlationId(delivery.getProperties().getCorrelationId())                    channel.basicPublish("", delivery.getProperties().getReplyTo(), replyProps, response.getBytes("UTF-8"));                    //手动确认                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);                    // RabbitMq consumer worker thread notifies the RPC server owner thread                    // 消费者线程通知服务者线程  保证线程安全                    synchronized (monitor) {                        monitor.notify();                    }                }            };            //接收客户端发来的消息  并将处理结果 返回去 deliverCallback            channel.basicConsume(RPC_QUEUE_NAME, false, deliverCallback, (consumerTag -> { }));            // Wait and be prepared to consume the message from RPC client.            while (true) {                synchronized (monitor) {                    try {                        monitor.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        }    }}