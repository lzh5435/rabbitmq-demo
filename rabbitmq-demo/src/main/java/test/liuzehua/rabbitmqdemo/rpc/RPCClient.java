package test.liuzehua.rabbitmqdemo.rpc;import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import test.liuzehua.rabbitmqdemo.utils.ConnectionFactoryUtil;import java.io.IOException;import java.util.UUID;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeoutException;public class RPCClient implements AutoCloseable {    private Connection connection;    private Channel channel;    private String requestQueueName = "rpc_queue";    public RPCClient() throws IOException {        connection = ConnectionFactoryUtil.getConnection();        channel = connection.createChannel();    }    public static void main(String[] argv) {        try (RPCClient fibonacciRpc = new RPCClient()) {            for (int i = 0; i < 32; i++) {                String i_str = Integer.toString(i);                System.out.println(" [x] Requesting fib(" + i_str + ")");                //发送请求                String response = fibonacciRpc.call(i_str);                //获取响应结果                System.out.println(" [.] Got '" + response + "'");            }        } catch (IOException  | InterruptedException e) {            e.printStackTrace();        }    }    public String call(String message) throws IOException, InterruptedException {        //rpc请求和响应的唯一关联        final String corrId = UUID.randomUUID().toString();        String replyQueueName = channel.queueDeclare().getQueue();        AMQP.BasicProperties props = new AMQP.BasicProperties                .Builder()                //rpc请求和响应的唯一关联                .correlationId(corrId)                //设置回调队列                .replyTo(replyQueueName)                .build();        //发送请求        channel.basicPublish("", requestQueueName, props, message.getBytes("UTF-8"));        //创建结果集        final BlockingQueue<String> response = new ArrayBlockingQueue<>(1);        //从回调队列  等待结果        String ctag = channel.basicConsume(replyQueueName, true, (consumerTag, delivery) -> {            //判断请求与响应是否一致            if (delivery.getProperties().getCorrelationId().equals(corrId)) {                //拿到结果                response.offer(new String(delivery.getBody(), "UTF-8"));            }        }, consumerTag -> {        });        //获取结果        String result = response.take();        channel.basicCancel(ctag);        return result;    }    public void close() throws IOException {        connection.close();    }   }